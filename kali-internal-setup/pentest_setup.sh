#!/usr/bin/env bash
#
# pentest_setup.sh
# Automated tool installer for authorized internal penetration testing
# Target: Kali Linux (NUC deployment)
#
# Usage: sudo ./pentest_setup.sh
#

set -uo pipefail

# ─── Colors ───────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# ─── Config ───────────────────────────────────────────────────────────────────
OPT_DIR="/opt"
LOGFILE="/var/log/pentest_setup.log"
declare -a FAILED_TOOLS=()
declare -a INSTALLED_TOOLS=()

# ─── Logging ──────────────────────────────────────────────────────────────────
log()     { echo -e "${BLUE}[*]${NC} $*" | tee -a "$LOGFILE"; }
success() { echo -e "${GREEN}[+]${NC} $*" | tee -a "$LOGFILE"; }
warn()    { echo -e "${YELLOW}[!]${NC} $*" | tee -a "$LOGFILE"; }
error()   { echo -e "${RED}[-]${NC} $*" | tee -a "$LOGFILE"; }
banner()  { echo -e "\n${CYAN}${BOLD}━━━ $* ━━━${NC}\n" | tee -a "$LOGFILE"; }

# ─── Helpers ──────────────────────────────────────────────────────────────────
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root.  Use: sudo $0"
        exit 1
    fi
}

# git_clone <display-name> <repo-url>
# Clones to $OPT_DIR/<display-name>; pulls if directory already exists.
git_clone() {
    local name="$1"
    local url="$2"
    local dir="$OPT_DIR/$name"

    if [[ -d "$dir/.git" ]]; then
        warn "$name already exists — pulling latest..."
        git -C "$dir" pull --ff-only >> "$LOGFILE" 2>&1 || \
            warn "Pull failed for $name, continuing with existing version"
        return 0
    fi

    log "Cloning $name..."
    git clone --recurse-submodules "$url" "$dir" >> "$LOGFILE" 2>&1 || {
        error "Clone failed: $name ($url)"
        FAILED_TOOLS+=("$name")
        return 1
    }
    success "$name cloned to $dir"
}

# py_install <display-name>
# Installs requirements.txt and/or setup.py/pyproject.toml for a tool in $OPT_DIR.
py_install() {
    local name="$1"
    local dir="$OPT_DIR/$name"
    local failed=0

    log "Installing Python dependencies for $name..."

    if [[ -f "$dir/requirements.txt" ]]; then
        pip3 install -r "$dir/requirements.txt" \
            --break-system-packages --quiet --root-user-action=ignore >> "$LOGFILE" 2>&1 || {
            warn "Some requirements failed for $name"
            failed=1
        }
    fi

    if [[ -f "$dir/setup.py" || -f "$dir/pyproject.toml" ]]; then
        pip3 install -e "$dir" \
            --break-system-packages --quiet --root-user-action=ignore >> "$LOGFILE" 2>&1 || {
            warn "pip install -e failed for $name"
            failed=1
        }
    fi

    return $failed
}

mark_done() {
    INSTALLED_TOOLS+=("$1")
    success "$1 installed successfully"
}

# ─── System Update & Upgrade ──────────────────────────────────────────────────
system_update() {
    banner "System Update & Upgrade"

    log "Updating package lists..."
    apt-get update -y >> "$LOGFILE" 2>&1 || { error "apt-get update failed"; exit 1; }

    log "Upgrading installed packages..."
    apt-get upgrade -y >> "$LOGFILE" 2>&1 || warn "Some packages failed to upgrade"

    log "Running dist-upgrade..."
    DEBIAN_FRONTEND=noninteractive apt-get dist-upgrade -y >> "$LOGFILE" 2>&1 || \
        warn "dist-upgrade encountered issues"

    apt-get autoremove -y >> "$LOGFILE" 2>&1
    apt-get autoclean -y  >> "$LOGFILE" 2>&1

    success "System update complete"
}

# ─── Base Dependencies ────────────────────────────────────────────────────────
install_base_deps() {
    banner "Base Dependencies"

    local pkgs=(
        git curl wget
        python3 python3-pip python3-dev python3-venv pipx
        build-essential libssl-dev libffi-dev
        libpcap-dev libkrb5-dev
        libldap2-dev libsasl2-dev ldap-utils
        golang-go
        nmap ncat
        jq unzip
    )

    log "Installing base packages..."
    apt-get install -y "${pkgs[@]}" >> "$LOGFILE" 2>&1 || \
        warn "One or more base packages failed — check the log"

    log "Configuring pipx path..."
    pipx ensurepath >> "$LOGFILE" 2>&1 || true

    # Install Rust via rustup — apt rustc is too old for several crates
    if ! command -v rustup &>/dev/null; then
        log "Installing Rust via rustup..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs \
            | sh -s -- -y --default-toolchain stable --no-modify-path >> "$LOGFILE" 2>&1 \
            || warn "rustup install failed"
    else
        warn "rustup already present — skipping"
    fi
    # Make rustup-managed cargo available for the rest of this session
    source "$HOME/.cargo/env" 2>/dev/null || export PATH="$HOME/.cargo/bin:$PATH"

    success "Base dependencies installed"
}

# ─── Tool: Croc ───────────────────────────────────────────────────────────────
install_croc() {
    banner "Croc"
    log "Installing croc via official installer..."
    curl -fsSL https://getcroc.schollz.com | bash >> "$LOGFILE" 2>&1 && \
        mark_done "croc" || { error "croc install failed"; FAILED_TOOLS+=("croc"); }
}

# ─── Tool: Responder ──────────────────────────────────────────────────────────
install_responder() {
    banner "Responder"
    git_clone "Responder" "https://github.com/lgandx/Responder" || return

    pip3 install netifaces --break-system-packages -q --root-user-action=ignore >> "$LOGFILE" 2>&1 || true
    chmod +x "$OPT_DIR/Responder/Responder.py"
    ln -sf "$OPT_DIR/Responder/Responder.py" /usr/local/bin/responder 2>/dev/null || true
    mark_done "Responder"
}

# ─── Tool: Certipy ────────────────────────────────────────────────────────────
install_certipy() {
    banner "Certipy"
    git_clone "Certipy" "https://github.com/ly4k/Certipy" || return
    # Use pipx to avoid conflicts with system-managed packages (e.g. beautifulsoup4)
    log "Installing Certipy via pipx..."
    pipx install "$OPT_DIR/Certipy" >> "$LOGFILE" 2>&1 && \
        mark_done "Certipy" || { error "Certipy install failed"; FAILED_TOOLS+=("Certipy"); }
}

# ─── Tool: KrbRelayX ──────────────────────────────────────────────────────────
install_krbrelayx() {
    banner "KrbRelayX"
    git_clone "krbrelayx" "https://github.com/dirkjanm/krbrelayx" || return
    py_install "krbrelayx" && mark_done "krbrelayx" || FAILED_TOOLS+=("krbrelayx")
}

# ─── Tool: mitm6 ──────────────────────────────────────────────────────────────
install_mitm6() {
    banner "mitm6"
    git_clone "mitm6" "https://github.com/dirkjanm/mitm6" || return
    py_install "mitm6" && mark_done "mitm6" || FAILED_TOOLS+=("mitm6")
}

# ─── Tool: LdapRelayScan ──────────────────────────────────────────────────────
install_ldaprelayscan() {
    banner "LdapRelayScan"
    git_clone "LdapRelayScan" "https://github.com/zyn3rgy/LdapRelayScan" || return
    py_install "LdapRelayScan" && mark_done "LdapRelayScan" || FAILED_TOOLS+=("LdapRelayScan")
}

# ─── Tool: cloud_enum ─────────────────────────────────────────────────────────
install_cloud_enum() {
    banner "cloud_enum"
    git_clone "cloud_enum" "https://github.com/initstring/cloud_enum" || return
    py_install "cloud_enum" && mark_done "cloud_enum" || FAILED_TOOLS+=("cloud_enum")
}

# ─── Tool: CloudHunter ────────────────────────────────────────────────────────
install_cloudhunter() {
    banner "CloudHunter"
    git_clone "CloudHunter" "https://github.com/belane/CloudHunter" || return
    py_install "CloudHunter" && mark_done "CloudHunter" || FAILED_TOOLS+=("CloudHunter")
}

# ─── Tool: dnshunter ──────────────────────────────────────────────────────────
install_dnshunter() {
    banner "dnshunter"
    git_clone "dnshunter" "https://github.com/5amu/dnshunter" || return

    # Build with Go if a go.mod is present; otherwise treat as Python
    if [[ -f "$OPT_DIR/dnshunter/go.mod" ]]; then
        log "Building dnshunter with Go..."
        # Use GOBIN so go install handles multi-package repos without the -o conflict
        (cd "$OPT_DIR/dnshunter" && GOBIN=/usr/local/bin go install ./... >> "$LOGFILE" 2>&1) && \
            mark_done "dnshunter" || {
                error "Go build failed for dnshunter"
                FAILED_TOOLS+=("dnshunter")
            }
    else
        py_install "dnshunter" && mark_done "dnshunter" || FAILED_TOOLS+=("dnshunter")
    fi
}

# ─── Tool: msftrecon ──────────────────────────────────────────────────────────
install_msftrecon() {
    banner "msftrecon"
    git_clone "msftrecon" "https://github.com/Arcanum-Sec/msftrecon" || return
    py_install "msftrecon" && mark_done "msftrecon" || FAILED_TOOLS+=("msftrecon")
}

# ─── Tool: PCredz ─────────────────────────────────────────────────────────────
install_pcredz() {
    banner "PCredz"
    git_clone "PCredz" "https://github.com/lgandx/PCredz" || return

    # PCredz needs libpcap Python bindings
    pip3 install python-libpcap Cython \
        --break-system-packages -q --root-user-action=ignore >> "$LOGFILE" 2>&1 || true
    py_install "PCredz"

    local bin="$OPT_DIR/PCredz/PCredz"
    [[ -f "$bin" ]] && chmod +x "$bin" && \
        ln -sf "$bin" /usr/local/bin/pcredz 2>/dev/null || true

    mark_done "PCredz"
}

# ─── Tool: lnk-it-up ─────────────────────────────────────────────────────────
install_lnkitup() {
    banner "lnk-it-up"
    git_clone "lnk-it-up" "https://github.com/wietze/lnk-it-up" || return
    py_install "lnk-it-up" && mark_done "lnk-it-up" || FAILED_TOOLS+=("lnk-it-up")
}

# ─── Tool: RustHound-CE ───────────────────────────────────────────────────────
install_rusthound() {
    banner "RustHound-CE"
    git_clone "RustHound-CE" "https://github.com/g0h4n/RustHound-CE" || return

    log "Building RustHound-CE with cargo (this may take a while)..."
    # Ensure rustup-managed cargo is used — apt rustc is too old for required crates
    source "$HOME/.cargo/env" 2>/dev/null || export PATH="$HOME/.cargo/bin:$PATH"
    (cd "$OPT_DIR/RustHound-CE" && cargo build --release >> "$LOGFILE" 2>&1) && {
        # Binary may be named rusthound-ce or rusthound depending on Cargo.toml
        local bin
        bin=$(find "$OPT_DIR/RustHound-CE/target/release" -maxdepth 1 -type f -executable \
            ! -name "*.d" | head -1)
        if [[ -n "$bin" ]]; then
            ln -sf "$bin" /usr/local/bin/rusthound-ce 2>/dev/null || true
            mark_done "RustHound-CE"
        else
            error "RustHound-CE binary not found after build"
            FAILED_TOOLS+=("RustHound-CE")
        fi
    } || {
        error "RustHound-CE cargo build failed"
        FAILED_TOOLS+=("RustHound-CE")
    }
}

# ─── Tool: Impacket ───────────────────────────────────────────────────────────
install_impacket() {
    banner "Impacket"
    git_clone "impacket" "https://github.com/fortra/impacket" || return
    py_install "impacket" && mark_done "impacket" || FAILED_TOOLS+=("impacket")
}

# ─── Tool: BloodHound.py ──────────────────────────────────────────────────────
install_bloodhound_py() {
    banner "BloodHound.py"
    git_clone "BloodHound.py" "https://github.com/dirkjanm/BloodHound.py" || return
    py_install "BloodHound.py" && mark_done "BloodHound.py" || FAILED_TOOLS+=("BloodHound.py")
}

# ─── Tool: NetExec ────────────────────────────────────────────────────────────
install_netexec() {
    banner "NetExec"
    git_clone "NetExec" "https://github.com/Pennyw0rth/NetExec" || return

    log "Installing NetExec via pipx..."
    pipx install "$OPT_DIR/NetExec" >> "$LOGFILE" 2>&1 && \
        mark_done "NetExec" || {
            warn "pipx install failed, falling back to pip..."
            py_install "NetExec" && mark_done "NetExec" || \
                { error "NetExec install failed"; FAILED_TOOLS+=("NetExec"); }
        }
}

# ─── Tool: Poetry ─────────────────────────────────────────────────────────────
install_poetry() {
    banner "Poetry"

    if command -v poetry &>/dev/null; then
        warn "Poetry already installed — updating..."
        poetry self update >> "$LOGFILE" 2>&1 || true
        mark_done "poetry"
        return
    fi

    log "Installing Poetry via official installer..."
    curl -sSL https://install.python-poetry.org | python3 - >> "$LOGFILE" 2>&1 && {
        # Make available system-wide; installer drops it in $HOME/.local/bin
        ln -sf "$HOME/.local/bin/poetry" /usr/local/bin/poetry 2>/dev/null || true
        mark_done "poetry"
    } || { error "Poetry install failed"; FAILED_TOOLS+=("poetry"); }
}

# ─── Tool: Coercer ────────────────────────────────────────────────────────────
install_coercer() {
    banner "Coercer"
    git_clone "Coercer" "https://github.com/p0dalirius/Coercer" || return
    py_install "Coercer" && mark_done "Coercer" || FAILED_TOOLS+=("Coercer")
}

# ─── Tool: pxethiefy ──────────────────────────────────────────────────────────
install_pxethiefy() {
    banner "pxethiefy"
    git_clone "pxethiefy" "https://github.com/csandker/pxethiefy" || return

    local dir="$OPT_DIR/pxethiefy"

    log "Creating Python venv for pxethiefy..."
    python3 -m venv "$dir/venv" >> "$LOGFILE" 2>&1 || {
        error "venv creation failed for pxethiefy"
        FAILED_TOOLS+=("pxethiefy")
        return 1
    }

    log "Installing pxethiefy dependencies into venv..."
    "$dir/venv/bin/pip" install -r "$dir/requirements.txt" --quiet >> "$LOGFILE" 2>&1 || {
        error "pxethiefy dependency install failed"
        FAILED_TOOLS+=("pxethiefy")
        return 1
    }

    # pxethiefy needs CAP_NET_RAW for raw packet access; wrapper escalates if needed
    cat > /usr/local/bin/pxethiefy <<'WRAPPER'
#!/usr/bin/env bash
# pxethiefy — PXE boot media discovery for SCCM environments
# Requires raw packet access; auto-escalates via sudo if not already root.
if [[ $EUID -ne 0 ]]; then
    exec sudo /opt/pxethiefy/venv/bin/python3 /opt/pxethiefy/pxethiefy.py "$@"
else
    exec /opt/pxethiefy/venv/bin/python3 /opt/pxethiefy/pxethiefy.py "$@"
fi
WRAPPER
    chmod +x /usr/local/bin/pxethiefy
    mark_done "pxethiefy"
}

# ─── Summary ──────────────────────────────────────────────────────────────────
print_summary() {
    local width=50
    local line; printf -v line '━%.0s' $(seq 1 $width)

    echo ""
    echo -e "${CYAN}${BOLD}${line}${NC}"
    printf "${CYAN}${BOLD}%-${width}s${NC}\n" "  SETUP COMPLETE"
    echo -e "${CYAN}${BOLD}${line}${NC}"

    echo -e "\n${GREEN}${BOLD}Installed (${#INSTALLED_TOOLS[@]})${NC}"
    for t in "${INSTALLED_TOOLS[@]}"; do
        echo -e "  ${GREEN}✓${NC}  $t"
    done

    if [[ ${#FAILED_TOOLS[@]} -gt 0 ]]; then
        echo -e "\n${RED}${BOLD}Failed (${#FAILED_TOOLS[@]})${NC}"
        for t in "${FAILED_TOOLS[@]}"; do
            echo -e "  ${RED}✗${NC}  $t"
        done
        echo -e "\n${YELLOW}[!] Review $LOGFILE for failure details${NC}"
    fi

    echo -e "\n${BLUE}[*] Tools installed to: $OPT_DIR${NC}"
    echo -e "${BLUE}[*] Full log:           $LOGFILE${NC}"
    echo -e "${CYAN}${BOLD}${line}${NC}\n"
}

# ─── Main ─────────────────────────────────────────────────────────────────────
main() {
    mkdir -p "$(dirname "$LOGFILE")"
    echo "=== Pentest NUC Setup Log — $(date) ===" > "$LOGFILE"

    check_root

    echo -e "${CYAN}${BOLD}"
    echo "  ╔══════════════════════════════════════════════╗"
    echo "  ║       Pentest NUC Setup — Kali Linux         ║"
    echo "  ║   Authorized Internal Penetration Testing    ║"
    echo "  ╚══════════════════════════════════════════════╝"
    echo -e "${NC}"
    log "Log file: $LOGFILE"

    system_update
    install_base_deps

    # ── Tools ──
    install_croc
    install_responder
    install_certipy
    install_krbrelayx
    install_mitm6
    install_ldaprelayscan
    install_cloud_enum
    install_cloudhunter
    install_dnshunter
    install_msftrecon
    install_pcredz
    install_lnkitup
    install_rusthound
    install_impacket
    install_bloodhound_py
    install_poetry       # must come before NetExec (Poetry is its build backend)
    install_netexec
    install_coercer
    install_pxethiefy

    print_summary
}

main "$@"
